# workflow

Used by the `cirrus` module to create cirrus workflow resources. Aside from
using the [Inputs](#inputs) section below as a reference for creating `workflow`
YAML definitions, interactions with this module should happen through the
interface provided by the `cirrus` module rather than using this module directly.

<!-- BEGIN_TF_DOCS -->
## Requirements

| Name | Version |
|------|---------|
| <a name="requirement_terraform"></a> [terraform](#requirement\_terraform) | >= 1.6.6 |
| <a name="requirement_aws"></a> [aws](#requirement\_aws) | ~> 5.22 |

## Providers

| Name | Version |
|------|---------|
| <a name="provider_aws"></a> [aws](#provider\_aws) | ~> 5.22 |

## Inputs

| Name | Description | Type | Default | Required |
|------|-------------|------|---------|:--------:|
| <a name="input_resource_prefix"></a> [resource\_prefix](#input\_resource\_prefix) | String prefix to be used in every named resource | `string` | n/a | yes |
| <a name="input_workflow_config"></a> [workflow\_config](#input\_workflow\_config) | Defines a single cirrus workflow.<br/><br/>`name`: Identifier for the cirrus workflow. Must be unique across all cirrus workflows. Valid characters are: `[A-Za-z0-9-]`.<br/><br/>`state_machine_filepath`: Path to an Amazon State Machine definition template file. The path must be relative to the ROOT module of the Terraform deployment. The template should use valid Amazon States Language syntax; wherever a Cirrus Task resource ARN is needed, a Terraform interpolation sequence (`${...}`) may be used instead. The interpolation sequence must have the following form:<pre>tasks.TASK-NAME.TASK-TYPE.TASK-ATTR</pre>Where:<pre>tasks     : static namespace for cirrus task outputs<br/>TASK-NAME : name of the cirrus task<br/>TASK-TYPE : one of [lambda, batch]<br/>TASK-ATTR : one of [function_arn, job_definition_arn, job_queue_arn]</pre>Example template snippet:<pre>"States": {<br/>  "FirstState": {<br/>    "Type": "Task",<br/>    "Resource": "\${tasks.my-task.lambda.function_arn}",<br/>    "Next": "SecondState",<br/>    ...<br/>  },<br/>  ...</pre>For references to environment-specific resources that are not managed by cirrus, such as an SQS queue, an interpolation sequence (`${...}`) can be used if you have a corresponding entry in the `var.workflow_definitions_variables` input map. See that variable's description for an example of this.<br/><br/>`role_statements`: List of IAM statements to be applied to the workflow's IAM role. Note that this role can already submit batch jobs and invoke lambda functions that are referenced in the state machine JSON, so you do not need to specify those permissions and may omit this setting if these default permissions are acceptable. If you will be invoking any additional AWS services, however, you must allow the necessary actions through a role statement. This list of objects is used to create a `aws_iam_policy_document` terraform data source. Refer to that data source's [documentation](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/data-sources/iam_policy_document) for more information on the available arguments.<br/><br/>IMPORTANT - IAM permissions work both ways; you may need to ensure the target AWS resource grants the generated workflow IAM role the necessary permissions (such as an SQS policy that allows the `sqs:SendMessage` action). This module will output the workflow role's ARN after the first successful deployment. If you delete and re-create the workflow for any reason, you will need to update any downstream permissions, too, even if the workflow role's name/ARN is the same due to how [IAM identifiers work](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-unique-ids). | <pre>object({<br/>    name = string<br/><br/>    state_machine_filepath = string<br/><br/>    role_statements = optional(list(object({<br/>      sid           = string<br/>      effect        = string<br/>      actions       = list(string)<br/>      resources     = list(string)<br/>      not_actions   = optional(list(string))<br/>      not_resources = optional(list(string))<br/>      condition = optional(object({<br/>        test     = string<br/>        variable = string<br/>        values   = list(string)<br/>      }))<br/>      principals = optional(object({<br/>        type        = string<br/>        identifiers = list(string)<br/>      }))<br/>      not_principals = optional(object({<br/>        type        = string<br/>        identifiers = list(string)<br/>      }))<br/>    })))<br/>    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br/>  })</pre> | n/a | yes |
| <a name="input_cirrus_tasks"></a> [cirrus\_tasks](#input\_cirrus\_tasks) | (Optional) A map of the `task` module outputs keyed by their task's `name`. These are used for variable interpolation in the workflow state machine definition template. | <pre>map(object({<br/>    lambda = object({<br/>      function_arn = optional(string)<br/>    })<br/>    batch = object({<br/>      job_queue_arn      = optional(string)<br/>      job_definition_arn = optional(string)<br/>    })<br/>  }))</pre> | `null` | no |
| <a name="input_workflow_definitions_variables"></a> [workflow\_definitions\_variables](#input\_workflow\_definitions\_variables) | (Optional) Map of maps to strings used when templating workflow state machine JSON definitions prior to machine creation. Intended for abstracting environment-specific values away from the state machine JSON.<br/><br/>This is only needed if your workflow's state machine will be using AWS services/resources that are unrelated to the cirrus tasks created by this module. One such example would be a workflow that leverages the callback task functionality provided by an `arn:aws:states:::sqs:sendMessage.waitForTaskToken` state machine resource that varies by environment.<br/><br/>If your state machine does not invoke any non-cirrus task resources, you do not need to use this.<br/><br/>The suggested (but not required) structure of this map is to group template variables by their workflow name:<pre>{<br/>  example-workflow-1 = {<br/>    callback_queue_arn = "dev-queue-arn"<br/>    callback_queue_url = "https://..."<br/>  }<br/>  example-workflow-2 = {<br/>    non_task_resource_arn = "dev-resource-arn"<br/>  }<br/><br/>  ... more workflow maps ...<br/>}</pre>A `State` within your workflow state machine JSON would look something like this:<pre>{<br/>  "Type": "Task",<br/>  "Resource": "arn:aws:states:::sqs:sendMessage.waitForTaskToken",<br/>  "Parameters": {<br/>      "QueueUrl": "\${example-workflow-1.callback_queue_url}",<br/>      "MessageBody": {<br/>          "Message": "Hello from Step Functions!",<br/>          "TaskToken.$": "$$.Task.Token"<br/>      }<br/>  },<br/>  "Next": "SOME_NEXT_STATE"<br/>}</pre>Each interpolation sequence's lookup value must have an associated entry in this map. If not, Terraform will raise a runtime error.<br/><br/>If `null` or `{}`, templating will technically still occur but nothing will be interpolated (provided your state machine JSON is also absent of interpolation sequences).<pre></pre> | `map(map(string))` | `{}` | no |
| <a name="input_builtin_workflow_definitions_variables"></a> [builtin\_workflow\_definitions\_variables](#input\_builtin\_workflow\_definitions\_variables) | (Optional) Similar to `var.workflow_definitions_variables` but for passing predefined builtin variables, such as `CIRRUS_DATA_BUCKET`, that are set in the `cirrus` module. These are used for templating the workflow state machine JSON.<br/><br/>This can't be merged with the user-defined `var.workflow_definitions_variables` in the `cirrus` module and passed as a single variable because the two maps may have differing structures/types, which terraform does not allow. | `map(string)` | `{}` | no |

## Outputs

| Name | Description |
|------|-------------|
| <a name="output_state_machine_arn"></a> [state\_machine\_arn](#output\_state\_machine\_arn) | n/a |
| <a name="output_state_machine_role_arn"></a> [state\_machine\_role\_arn](#output\_state\_machine\_role\_arn) | n/a |
<!-- END_TF_DOCS -->
